<link rel="import" href="../rise-storage/rise-storage.html">
<link rel="import" href="rise-story-thumbnail.html">

<polymer-element name="rise-story" attributes="companyId folder folderRefresh">
  <template>
    <style>
      :host {
        display: block;
        margin: 0;
        padding: 0;
        height: 100%;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        pointer-events: none;
      }

      :host > div {
        display: block;
        list-style: none;
        margin: 0;
        padding: 0;
        text-align: center;
        position: relative;
        width: 100%;
        height: 100%;
      }

      /* fade in/out */

      .fade {
        opacity: 1;
        transition: opacity .3s ease-in;
      }
      .fade-in {
        opacity: 1;
      }
      .hidden {
        opacity: 0;
        display: none;
      }

      /* sizing */

      .thumbnail {
        max-width: 38.2vmin;
        max-height: 38.2vmin;

        transition:
          max-width .3s ease-in,
          max-height .3s ease-in,
          transform .3s ease-in;
      }

      .full {
        transform: none !important;
        max-width: 85.4vmin;
        max-height: 85.4vmin;

        transition:
          max-width .7s cubic-bezier(.35,-0.33,.57,1.28),
          max-height .7s cubic-bezier(.35,-0.33,.57,1.28),
          transform .3s ease-out;
      }
    </style>

    <rise-storage id="storage"
      companyId="{{companyId}}"
      folder="{{folder}}"
      folderRefresh="{{folderRefresh}}"
      on-rise-storage-response="{{storageResponse}}"
    >
    </rise-storage>
    <div id="gallery" on-click="{{playerClick}}"></div>
  </template>

  <script src="node_modules/knuth-shuffle/index.js"></script>
  <script>
  /*global Polymer, knuthShuffle, DOMTokenList*/
  (function() {
    "use strict";

    // PRIVATE IMPLEMENTATION
    var riseStoryElement;
    var player = {};
    var playing = false;
    var paused = false;
    var pausedTimeout = 3000;

    var MIN_Z_INDEX = 1;
    var zindex = MIN_Z_INDEX;

    var sequence = [
      { duration:  100, on: "thumbnail focus",   off: "fade-in hidden"    },
      { duration:  750, on: "full",              off: "thumbnail fade-in" },
      { duration: 3500, on: "fade-in thumbnail", off: "full focus"        },
      { duration:  700, on: "fade-in thumbnail", off: "full focus"        },
    ];
    var sequencePauseIndex = 1;

    var playQueue;
    var mediaIndex = 0;
    var animationIndex = 0;
    var then = Date.now();

    // is an element hidden?
    function isHidden(domElement) {
      return domElement.classList.contains("hidden");
    }

    // remove style property
    // omit value to reset style to "undefined"
    function setStyle(styleMap) {
      return function(domElement) {
        Object.keys(styleMap).forEach(function(prop) {
          domElement.style[prop] = styleMap[prop];
        });
      };
    }

    // set animation state
    function setAnimationState(element, classObject) {
      DOMTokenList.prototype.add.apply(element.classList, classObject.on.split(" "));
      DOMTokenList.prototype.remove.apply(element.classList, classObject.off.split(" "));
    }


    // render the animation sequence
    function animateFrame() {
      var now = Date.now();

      // time to update?
      if (playing && now - then >= sequence[animationIndex].duration) {
        if (mediaIndex >= playQueue.length) {
          if (playQueue.length === 0) {
            return;
          }
          riseStoryElement.shuffle();
        }

        // update classes
        if (animationIndex === 0) {
          playQueue[mediaIndex].style.zIndex = ++zindex;
        }
        setAnimationState(playQueue[mediaIndex], sequence[animationIndex]);

        // next in sequence
        then = now;
        animationIndex = (animationIndex + 1) % sequence.length;

        // prepare next image
        if (animationIndex === 0) {
          mediaIndex++;
        }
      }

      // paused?
      if (paused) {
        // set pause duration
        then += pausedTimeout;
        paused = false;
      }

      // loop
      if (playing) {
        requestAnimationFrame(animateFrame);
      }
    }


    // POLYMER ELEMENT - PUBLIC API

    /*jshint newcap: false */
    Polymer("rise-story", {

      /**
       * The ID of the Company.
       *
       * @attribute companyId
       * @type string
       * @default ''
       */
      companyId: "",

      /**
       * The folder name.
       *
       * @attribute folder
       * @type string
       * @default ''
       */
      folder: "",

      /**
       * The number of seconds before the folder will be checked for changes.

       *
       * @attribute folderRefresh
       * @type number
       * @default 0 (no refresh)
       */
      folderRefresh: 0,


      // clears screen and starts playback
      reset: function reset() {

      },


      // pause the slideshow
      pause: function pause() {
        if (! paused) {
          animationIndex = sequencePauseIndex;
          paused = true;
          then = 0; // triggers animation to run
        }
        return player;
      },

      // play
      play: function play() {
        then = Math.min(then, Date.now());
        if (! playing || paused) {
          playing = true;
          paused = false;
          requestAnimationFrame(animateFrame);
        }

        return player;
      },

      // pause toggle
      playToggle: function playToggle() {
        if (playing) {
          this.pause();
        } else {
          this.play();
        }
      },

      // stop
      stop: function stop() {
        if (playing) {
          playing = false;
          paused = false;
          animationIndex = sequence.length - 1;
          // finish current element
          setAnimationState(playQueue[mediaIndex], sequence[animationIndex]);
        }
        return player;
      },


      // shuffle items for playback
      shuffle: function shuffle() {
        var unseenItemsInQueue = playQueue.filter(isHidden);

        zindex = MIN_Z_INDEX;

        if (unseenItemsInQueue.length) {
          playQueue = playQueue.filter(function(item) {
            return unseenItemsInQueue.indexOf(item) === -1;
          });
          // reset zindex
          for (var i = 0; i < playQueue.length; i++) {
            playQueue[i].style.zIndex = ++zindex;
          }
          // put hidden items first
          knuthShuffle(unseenItemsInQueue);
          knuthShuffle(playQueue);
          playQueue = unseenItemsInQueue.concat(playQueue);
        } else {
          // shuffle the order
          knuthShuffle(playQueue);
        }

        // shuffle onscreen positions
        playQueue.forEach(function(li) {
          // randomly position
          var x = Math.floor(Math.random() * window.innerWidth) - (window.innerWidth / 2);
          var y = Math.floor(Math.random() * window.innerHeight) - (window.innerHeight / 2);
          var r = Math.floor(Math.random() * 42) - 21;
          li.style.transform = "translate(" + x + "px, " + y + "px) rotate(" + r + "deg)";
        });

        // reset
        playQueue.forEach(setStyle({ "z-index": 1 }));
        mediaIndex = 0;
      },

      // click on media
      playerClick: function playerClick(event) {
        event.stopImmediatePropagation();

        var item = event.target;
        var selectedIndex, selectedItem, upcoming;

        // find LI ancestor
        while (/^BUTTON|FIGURE|IMG$/i.test(item.tagName) && item.parentNode) {
          item = item.parentNode;
        }
        // is it a media element? find it
        selectedIndex = playQueue.indexOf(item);

        // selected active item
        if (selectedIndex === mediaIndex) {
          // just pause
          if (! playing) {
            this.play();
          } else {
            this.pause();
          }

        } else if (selectedIndex < playQueue.length) {
          this.stop();
          upcoming = selectedIndex > mediaIndex;

          // move to next play position
          selectedItem = playQueue.splice(selectedIndex, 1)[0];
          if (upcoming) {
            mediaIndex++;
          }
          playQueue.splice(mediaIndex, 0, selectedItem);

          // reset animation
          animationIndex = 0;
          this.play();
        }
      },

      storageResponse: function storageResponse(e) {
        var files = e.detail.files;

        // setup DOM
        var mediaList = this.$.gallery;
        var oldMediaList = {};
        Array.prototype.forEach.call(mediaList.children, function(li) {
          var src = li.querySelector("img").src;
          oldMediaList[src] = li;
        });

        var newItems = [];

        files.forEach(function(file) {
          var src = file.url;
          // already have this element
          if (oldMediaList[src]) {
            delete oldMediaList[src];
            return;
          }

          // var li = document.createElement("li");
          // var figure = document.createElement("figure");
          // var button = document.createElement("button");
          // var img = document.createElement("img");
          // img.src = src;
          // img.alt = "";
          var li = document.createElement('rise-story-thumbnail');
          li.src = src;

          // initial animation classes
          li.classList.add("hidden", "fade", "fade-in", "thumbnail");

          // add to DOM
          // button.appendChild(img);
          // figure.appendChild(button);
          // li.appendChild(figure);
          newItems.push(li);
        });

        // stop playing
        this.stop();

        // remove anything left on the old media list
        Object.keys(oldMediaList).forEach(function(key) {
          oldMediaList[key].remove();
        });

        // add new media
        newItems.forEach(function(li) {
          mediaList.appendChild(li);
        });

        // get the new children list
        playQueue = Array.prototype.slice.call(mediaList.children);
        this.shuffle();

        // go
        animationIndex = 0;
        this.play();
      },


      // polymer ready
      ready: function() {
        // access to 'this' for requestAnimationFrame
        riseStoryElement = this;

        // grab data from storage
        this.$.storage.go();
      }
    }); // Polymer()


  }()); // closure
  </script>
</polymer-element>
